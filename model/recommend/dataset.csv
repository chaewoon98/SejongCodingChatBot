의도(Intent),개체명(NER),언어(Language),키워드(Keyword),타이틀(Title),설명(Description),질문(Query),답변(Answer),답변이미지
정의,B_LV1,c,출력,출력함수 printf,printf 출력함수 출력,{B_LV1}에 대해 알려줘,"답변: 출력함수 printf를 사용하면 화면에 출력할 수 있습니다. printf(""...""); 와 같이 print함수 안에서 큰 따옴표를 사용하면 원하는 문자열을 출력할 수 있습니다. 형식 지정자를 사용해서 출력하면 원하는 형식의 데이터를 출력할 수 있습니다. Int형의 형식 지정자는 %d, char형의 형식 지정자는 %c, float와 double형의 형식 지정자는 %f, 문자열의 형식 지정자는 %s 입니다.

예시) 
int num = 100;
printf(""num = %d"", num);
실행결과) num = 100",
정의,B_LV1,c,printf,,,{B_LV1}에 대해 알려줘,"답변: 출력함수 printf를 사용하면 화면에 출력할 수 있습니다. printf(""...""); 와 같이 print함수 안에서 큰 따옴표를 사용하면 원하는 문자열을 출력할 수 있습니다. 형식 지정자를 사용해서 출력하면 원하는 형식의 데이터를 출력할 수 있습니다. Int형의 형식 지정자는 %d, char형의 형식 지정자는 %c, float와 double형의 형식 지정자는 %f, 문자열의 형식 지정자는 %s 입니다.

예시) 
int num = 100;
printf(""num = %d"", num);
실행결과) num = 100",
정의,B_LV1,c,출력함수,,,{B_LV1}에 대해 알려줘,"답변: 출력함수 printf를 사용하면 화면에 출력할 수 있습니다. printf(""...""); 와 같이 print함수 안에서 큰 따옴표를 사용하면 원하는 문자열을 출력할 수 있습니다. 형식 지정자를 사용해서 출력하면 원하는 형식의 데이터를 출력할 수 있습니다. Int형의 형식 지정자는 %d, char형의 형식 지정자는 %c, float와 double형의 형식 지정자는 %f, 문자열의 형식 지정자는 %s 입니다.

예시) 
int num = 100;
printf(""num = %d"", num);
실행결과) num = 100",
정의,B_LV1,c,줄바꿈,줄바꿈 출력,줄바꿈 개행 출력,{B_LV1}에 대해 알려줘,"답변: 줄 바꿈 기호는 \n 또는 역슬래시n 입니다. 명령을 두줄에 걸쳐 작성한다고 해서 줄 바꿈이 일어나지 않습니다.  

예시) printf(""Hello World!\n"");",
정의,B_LV1,c,개행,,,{B_LV1}에 대해 알려줘,"답변: 줄 바꿈 기호는 \n 또는 역슬래시n 입니다. 명령을 두줄에 걸쳐 작성한다고 해서 줄 바꿈이 일어나지 않습니다.  

예시) printf(""Hello World!\n"");",
정의,B_LV1,c,탭 출력,탭 출력,탭 tab 출력,{B_LV1}에 대해 알려줘,"답변: 탭 기호는 \t 또는 역슬래시t 입니다. 

예시) printf(""\t Hello World!"");
실행 결과)      Hello World!",
정의,B_LV1,c,tab 출력,,,{B_LV1}에 대해 알려줘,"답변: 탭 기호는 \t 또는 역슬래시t 입니다. 

예시) printf(""\t Hello World!"");
실행 결과)      Hello World!",
정의,B_LV1,c,따옴표 출력,따옴표 출력,기호 출력 따옴표 출력,{B_LV1}에 대해 알려줘,"답변: 큰 따옴표/작은 따옴표를 출력하려면 \또는 역슬래시를 따옴표 기호 앞에 붙여서 사용하세요. 
예시) printf(""\""Hello World!\""""); 
실행 결과) ""Hello World""",
정의,B_LV1,c,큰따옴표 출력,,,{B_LV1}에 대해 알려줘,"답변: 큰 따옴표/작은 따옴표를 출력하려면 \또는 역슬래시를 따옴표 기호 앞에 붙여서 사용하세요. 
예시) printf(""\""Hello World!\""""); 
실행 결과) ""Hello World""",
정의,B_LV1,c,작은따옴표 출력,,,{B_LV1}에 대해 알려줘,"답변: 큰 따옴표/작은 따옴표를 출력하려면 \또는 역슬래시를 따옴표 기호 앞에 붙여서 사용하세요. 
예시) printf(""\""Hello World!\""""); 
실행 결과) ""Hello World""",
정의,B_LV1,c,퍼센트 출력,퍼센트 출력,퍼센트 출력,{B_LV1}에 대해 알려줘,"답변: % 기호를 출력하려면 ""%%""와 같이 2번 연속으로 사용하세요.

예시) printf(""퍼센트 출력: %%"");
실행 결과) 퍼센트 출력: %\n",
정의,B_LV1,c,변수 선언,변수 선언,변수 선언,{B_LV1}에 대해 알려줘,"답변: 변수란 값을 저장할 수 있는 메모리 공간입니다. 변수를 사용하려면 먼저 변수 선언을 해주어야 합니다. 변수 선언은 변수의 자료형, 이름을 지정해주는 것입니다. 자료형은 정수형, 문자형, 부동소수점형 등 어떤 형식의 값을 변수에 저장할 것인지 지정하는 것으로 변수명 앞에 붙여서 사용합니다. 변수명은 용도를 알아볼 수 있도록 의미를 부여하는 것이 좋습니다. 

예시) int sum;
double average;",
정의,B_LV1,c,변수 초기화,변수 초기화,변수 초기화,{B_LV1}에 대해 알려줘,"답변: 초기화란 데이터를 변수에 저장하는 것입니다. 초기화는 변수 선언과 동시에 할 수도 있습니다.

예시) int num = 100;",
정의,B_LV1,c,변수명,변수명 짓기,변수명 변수이름  ,{B_LV1}에 대해 알려줘,"답변: 변수명은 용도를 알아볼 수 있도록 의미를 부여하는 것이 좋습니다.
변수를 작명할때 유의사항은 다음과 같습니다.

1. 변수의 이름은 알파벳, 숫자, 언더바( _ )로 구성되며 공백이 포함될 수 없다.
2. 변수의 이름은 숫자로 시작할 수 없다. 
3. int, if, case 등 c언어에서 키워드로 예약된 단어는 변수명으로 사용할 수 없다.
",
정의,B_LV1,c,변수 이름,,,{B_LV1}에 대해 알려줘,"답변: 변수명은 용도를 알아볼 수 있도록 의미를 부여하는 것이 좋습니다.
변수를 작명할때 유의사항은 다음과 같습니다.

1. 변수의 이름은 알파벳, 숫자, 언더바( _ )로 구성되며 공백이 포함될 수 없다.
2. 변수의 이름은 숫자로 시작할 수 없다. 
3. int, if, case 등 c언어에서 키워드로 예약된 단어는 변수명으로 사용할 수 없다.
",
정의,B_LV1,c,자료형,자료형,자료형,{B_LV1}에 대해 알려줘,"답변:  자료형이란 변수에 저장될 데이터의 종류를 의미합니다. 변수에 값을 담기 전에 정수, 실수, 문자, 문자열 등 값의 종류 그리고 값의 범위에 따라 지정하는 것으로 변수 앞에 붙여서 사용합니다. 정수형 자료형으로는 int, char, short, long 등이 있습니다. 실수형 자료형으로는 float, double, long double 등이 있습니다.",
정의,B_LV1,c,입력,입력함수 scanf,입력 입력함수 scanf 키모드입력,{B_LV1}에 대해 알려줘,"답변: scanf를 사용하여 키보드 입력을 받을 수 있습니다. 입력 받고자 하는 값의 자료형에 맞는 형식지정자와 입력값을 넣을 변수명을 입력해주어야 합니다. 입력 형식은 scanf(""형식 지정자"", &변수명); 입니다.
만약 정수형 변수인 num에 값을 입력하고 싶다면 다음과 같이 입력해주면 됩니다. 
예시) scanf(""%d"", &num);",
정의,B_LV1,c,scanf 입력,,,{B_LV1}에 대해 알려줘,"답변: scanf를 사용하여 키보드 입력을 받을 수 있습니다. 입력 받고자 하는 값의 자료형에 맞는 형식지정자와 입력값을 넣을 변수명을 입력해주어야 합니다. 입력 형식은 scanf(""형식 지정자"", &변수명); 입니다.
만약 정수형 변수인 num에 값을 입력하고 싶다면 다음과 같이 입력해주면 됩니다. 
예시) scanf(""%d"", &num);",
정의,B_LV1,c,키보드입력,,,{B_LV1}에 대해 알려줘,"답변: scanf를 사용하여 키보드 입력을 받을 수 있습니다. 입력 받고자 하는 값의 자료형에 맞는 형식지정자와 입력값을 넣을 변수명을 입력해주어야 합니다. 입력 형식은 scanf(""형식 지정자"", &변수명); 입니다.
만약 정수형 변수인 num에 값을 입력하고 싶다면 다음과 같이 입력해주면 됩니다. 
예시) scanf(""%d"", &num);",
정의,B_LV1,c,조건문,조건문,조건문,{B_LV1}에 대해 알려줘,"답변: 조건문이란 조건에 따라 프로그램의 흐름을 바꾸는 구문입니다. 조건을 표현하기 위해서는 관계 연산자와 논리연산자를 이용합니다. 대표적인 조건문으로는 if문, if ~else문, switch문 등이 있습니다.",
정의,B_LV1,c,관계연산자,관계연산자,관계연산자 연산자,{B_LV1}에 대해 알려줘,"답변: 관계연산자는 조건문에서 조건을 표현하기 위해 사용됩니다.
x < y : x가 y보다 작으면 참
x > y : x가 y보다 크면 참
x == y : x와 y가 같으면 참
x != y : x와 y가 다르면 참
x <= y : x가 y보다 작거나 같으면 참
x >= y : x가 y보다 크거나 같으면 참",
정의,B_LV1,c,조건 삼항 연산자,조건 삼항 연산자,조건 삼항 연산자,{B_LV1}에 대해 알려줘,"답변: 조건 연산자를 사용하면 if ~else 문을 간결하게 사용할 수 있습니다.
조건? A: B 형태로 이루어져 있습니다. 조건이 참이면 A가 반환되고 조건이 거짓이면 B가 반환됩니다.

예시) x = (y>0)? 10: 20;
설명) y가 0보다 크면 x에 10이 대입되고, y가 0보다 작거나 같으면 20이 대입됩니다.",
정의,B_LV1,c,논리 연산자,논리 연산자,논리연산자 연산자,{B_LV1}에 대해 알려줘,"답변: 논리 연산자는 두개 이상의 조건 또는 연산식을 하나로 묶어서 참/거짓을 판단하는 연산자입니다. 대표적으로 &&, ||, ! 연산자가 있습니다.
A && B : AND연산자, A와 B가 모두 참이면 참
A || B : OR연산자, A와 B 둘 중의 하나라도 참이면 참
!A :  NOT연산자, 참은 거짓으로, 거짓은 참으로",
정의,B_LV1,c,if문,if문,if if문 조건문 ,{B_LV1}에 대해 알려줘,"답변: 원하는 조건과 조건이 참일때 실행하고자 하는 명령을 작성해주어야 합니다. if(조건) 명령문 과 같은 형식으로 사용할 수 있습니다. 하나의 if문 안에서 두개 이상의 명령문을 실행할 경우 중괄호 { } 를 사용해주어야 합니다. 
예시)
if(age < 19){
         printf(""19세 미만입니다."");
         printf(""서비스를 이용할 수 없습니다."");
}",
정의,B_LV1,c,if,,,{B_LV1}에 대해 알려줘,"답변: 원하는 조건과 조건이 참일때 실행하고자 하는 명령을 작성해주어야 합니다. if(조건) 명령문 과 같은 형식으로 사용할 수 있습니다. 하나의 if문 안에서 두개 이상의 명령문을 실행할 경우 중괄호 { } 를 사용해주어야 합니다. 
예시)
if(age < 19){
         printf(""19세 미만입니다."");
         printf(""서비스를 이용할 수 없습니다."");
}",
정의,B_LV1,c,elif문,else if문,elif문 elseif문 조건문,{B_LV1}에 대해 알려줘,"답변: if문과 달리 if문이 거짓일 때 실행하려는 명령문을 넣을 수 있습니다. else if를 사용하여 조건을 여러 개 사용할 수도 있습니다.
if(조건문 A) {
      조건 A가 참일 때 실행하려는 명령문
}else if(조건문 B){
      조건A가 거짓이고 조건 B가 참일 때 실행하려는 명령문
}else{
      조건 A, B가 모두 거짓일 때 실행하려는 명령문
}",
정의,B_LV1,c,else if문,,,{B_LV1}에 대해 알려줘,"답변: if문과 달리 if문이 거짓일 때 실행하려는 명령문을 넣을 수 있습니다. else if를 사용하여 조건을 여러 개 사용할 수도 있습니다.
if(조건문 A) {
      조건 A가 참일 때 실행하려는 명령문
}else if(조건문 B){
      조건A가 거짓이고 조건 B가 참일 때 실행하려는 명령문
}else{
      조건 A, B가 모두 거짓일 때 실행하려는 명령문
}",
정의,B_LV1,c,switch문,switch문,switch문 조건문,{B_LV1}에 대해 알려줘,"답변: switch문은 비교할 변수가 어떤 값을 가지는지에 따라 명령문이 실행됩니다. If문은 <, >, <=, >= 과 같은 조건을 비교할 수 있는데 반해, switch문은 == 조건만 판단할 수 있습니다. 그러나 if문보다 더 간결한 코드를 작성할 수 있다는 장점이 있습니다. 
예시)
switch(변수){
    case 값1 : 
        명령문 
        break;
    case 값2 : 
        명령문
        break;  
    default :   //위의 모든 케이스에 해당하지 않는 경우 실행됩니다.
        명령문    
}",
정의,B_LV1,c,switch,,,{B_LV1}에 대해 알려줘,"답변: switch문은 비교할 변수가 어떤 값을 가지는지에 따라 명령문이 실행됩니다. If문은 <, >, <=, >= 과 같은 조건을 비교할 수 있는데 반해, switch문은 == 조건만 판단할 수 있습니다. 그러나 if문보다 더 간결한 코드를 작성할 수 있다는 장점이 있습니다. 
예시)
switch(변수){
    case 값1 : 
        명령문 
        break;
    case 값2 : 
        명령문
        break;  
    default :   //위의 모든 케이스에 해당하지 않는 경우 실행됩니다.
        명령문    
}",
정의,B_LV1,c,반복문,,,{B_LV2}에 대해 알려줘,"답변: 반복문이란 특정 명령을 반복적으로 수행하도록 제어하는 명령문 입니다. 대표적으로 while문, do while문, for문이 있습니다.",
정의,B_LV1,c,while문,while문,while문 반복문,{B_LV3}에 대해 알려줘,"답변: while문은 반복문의 일종입니다. While문의 조건이 참이면 코드를 계속 반복합니다. While문 안의 명령문이 한번 실행되기 전마다 조건이 참인지 체크합니다. 만약 조건이 거짓일경우 반복을 멈추고 while문을 빠져나옵니다. 조건문을 잘못 작성하는 경우 반복문에서 빠져나오지 못하는 무한반복문이 생성될 수 있으니 종료 조건을 잘 작성하는 것이 중요합니다.\n
예시) \n
while(조건){\n
     반복해서 실행할 명령문\n
}",
정의,B_LV1,c,for문,for문,for문 반복문,{B_LV4}에 대해 알려줘,"답변: for문은 반복 횟수가 정해져 있는 경우 주로 사용하는 반복문입니다. 초기문, 조건문, 증감문 으로 구성되어 있습니다. 초기문에서 설정한 값에서부터 증감문에서 설정한 만큼씩을 증감시키는 것을 반복하다가 해당 값이 조건문에서 거짓이 되면 반복을 종료합니다. 형식은 다음과 같습니다.\n
for(초기문; 조건문; 증감문){\n
     반복해서 실행할 명령문\n
}\n
\n
예시) \n
for(int i=0; i<=10; i++){\n
      printf(""반복문 실행\n"");\n
}\n
설명) i가 0일때부터 10이 될 때까지 1씩 증가하면서 ""반복문 실행""을 출력한다. i가 11이 되면 조건이 거짓이 되기 때문에 반복을 종료한다. 즉 명령문은 i가 0일때부터 10일때까지 11번 실행된다.",
정의,B_LV1,c,이중 반복문,이중 for문,이중 반복문 이중 for문 이중반복문 이중for문,{B_LV5}에 대해 알려줘,"답변: 이중 반복문이란 두개의 반복문이 중첩된 것으로, 반복문 안에 반복문이 들어가 있는 것입니다. 이중반복문 중에서 For문이 중첩된 것을 이중 for문 이라고 합니다. \n
예시)\n
for(int i=0; i<5; i++){\n
      for(int j=0; j<10; j++){\n
	      printf(“Hello world!”);\n
      }\n
}",
정의,B_LV1,c,이중 for문,,,{B_LV5}에 대해 알려줘,"답변: 이중 반복문이란 두개의 반복문이 중첩된 것으로, 반복문 안에 반복문이 들어가 있는 것입니다. 이중반복문 중에서 For문이 중첩된 것을 이중 for문 이라고 합니다. \n
예시)\n
for(int i=0; i<5; i++){\n
      for(int j=0; j<10; j++){\n
	      printf(“Hello world!”);\n
      }\n
}",
정의,B_LV1,c,배열,배열,배열,{B_LV6}에 대해 알려줘,"답변: 배열이란 한가지 자료형을 연속적으로 나열하는 것으로, 같은 자료형의 변수들을 필요한 만큼 한번에 만들어 사용할 수 있습니다. 선언은 자료형 변수이름[개수]; 와 같이 사용하면 됩니다. \n
만약 크기가 5이고 이름이 x인 정수형 배열을 선언하려면 int x[5]; 와 같이 작성하면 됩니다. 이때 각 변수는 x[0], x[1], x[2], x[3], x[4] 가 됩니다. 괄호 안의 숫자를 인덱스라고 하며 배열의 인덱스는 항상 0부터 시작합니다.",
정의,B_LV1,c,배열 초기화,배열 초기화,배열 초기화,{B_LV7}에 대해 알려줘,"답변: 배열을 초기화 하는 방법은 다음과 같습니다.\n
x[5] = {1,2,3,4,5};\n
만약 배열을 초기화 하지 않으면 쓰레기값이 저장되게 됩니다. ",
정의,B_LV1,c,다차원 배열,다차원 배열,다차원 배열 2자원배열,{B_LV8}에 대해 알려줘,"\n
답변: 다차원 배열은 2차원 이상의 배열을 의미하며 변수를 구분하는 인덱스를 2개 이상 사용하는 것을 나타냅니다. \n
2차원 배열의 경우 자료형 배열이름[열의 길이][행의 길이] 와 같은 형식으로 나타낼 수 있습니다. 이때, 변수의 개수는 열의 길이 x 행의 길이가 됩니다.\n
\n
예시) int score[2][3] = {{10,20,50},{20,30,40}}; \n
설명) 다음과 같이 배열을 선언 및 초기화 하였을 때 각 변수의 값은 다음과 같습니다.\n
score[0][0] = 10\n
score[0][1] = 20\n
score[0][2] = 50\n
score[1][0] = 20\n
score[1][1] = 30\n
score[1][2] = 40\n
",
정의,B_LV1,c,2차원 배열 출력,,,{B_LV8}에 대해 알려줘,"\n
답변: 다차원 배열은 2차원 이상의 배열을 의미하며 변수를 구분하는 인덱스를 2개 이상 사용하는 것을 나타냅니다. \n
2차원 배열의 경우 자료형 배열이름[열의 길이][행의 길이] 와 같은 형식으로 나타낼 수 있습니다. 이때, 변수의 개수는 열의 길이 x 행의 길이가 됩니다.\n
\n
예시) int score[2][3] = {{10,20,50},{20,30,40}}; \n
설명) 다음과 같이 배열을 선언 및 초기화 하였을 때 각 변수의 값은 다음과 같습니다.\n
score[0][0] = 10\n
score[0][1] = 20\n
score[0][2] = 50\n
score[1][0] = 20\n
score[1][1] = 30\n
score[1][2] = 40\n
",
정의,B_LV1,c,배열 출력,배열 출력,배열 출력 반복문,{B_LV9}에 대해 알려줘,"답변: 배열을 출력할 때에는 반복문을 사용하면 편리하게 출력할 수 있습니다. \n
예시)\n
int x[5] = {1,2,3,4,5};\n
for(int i=0; i<5; i++){\n
   printf("" %d"", x[i]); \n
}",
정의,B_LV1,c,2차원 배열 출력,2차원 배열 출력,2차원 배열 출력 반복문 이중 for문,{B_LV10}에 대해 알려줘,"답변: 2차원 배열을 출력할 때에 다음과 같이 이중 반복문을 사용할 수 있습니다.\n
\n
예시)\n
int score[2][3] = {{10,20,50},{20,30,40}}; \n
for(int i=0; i<2; i++){\n
   for(int j=0; j<3; j++){\n
      printf("" %d"", x[i][j]);\n
   }\n
}",
정의,B_LV1,C,함수 이유,함수,함수 이유 필요 사용,{B_LV1}에 대해 알려줘,"C언어에서 아주 필수적인 문법이라고 할 수 있다. 함수란 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드 집합입니다. 우리는 이 함수를 이용한다면 반복적인 프로그래밍을 피할 수 있게 됩니다. 프로그램에서 특정 작업을 반복해야 할 때, 그 작업들을 함수로서 정의하면 코드를 간결하게하고 프로그래머의 불편을 줄이면서 효율적인 코드를 작성할 수 있게 됩니다.

C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}

다음과 같이 표현됩니다.

참조
http://tcpschool.com/c/c_function_basic
https://reakwon.tistory.com/51",
정의,B_LV1,C,함수 필요,,,{B_LV1}에 대해 알려줘,"C언어에서 아주 필수적인 문법이라고 할 수 있다. 함수란 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드 집합입니다. 우리는 이 함수를 이용한다면 반복적인 프로그래밍을 피할 수 있게 됩니다. 프로그램에서 특정 작업을 반복해야 할 때, 그 작업들을 함수로서 정의하면 코드를 간결하게하고 프로그래머의 불편을 줄이면서 효율적인 코드를 작성할 수 있게 됩니다.

C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}

다음과 같이 표현됩니다.

참조
http://tcpschool.com/c/c_function_basic
https://reakwon.tistory.com/51",
정의,B_LV1,C,함수,,,{B_LV1}에 대해 알려줘,"C언어에서 아주 필수적인 문법이라고 할 수 있다. 함수란 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드 집합입니다. 우리는 이 함수를 이용한다면 반복적인 프로그래밍을 피할 수 있게 됩니다. 프로그램에서 특정 작업을 반복해야 할 때, 그 작업들을 함수로서 정의하면 코드를 간결하게하고 프로그래머의 불편을 줄이면서 효율적인 코드를 작성할 수 있게 됩니다.

C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}

다음과 같이 표현됩니다.

참조
http://tcpschool.com/c/c_function_basic
https://reakwon.tistory.com/51",
정의,B_LV1,C,함수 오류,함수 오류,함수 오류 에러 문제,{B_LV1}에 대해 알려줘,"함수를 사용하면서 오류가 발생할때 다음을 참고해보세요.

1. 매개변수의 개수와 자료형이 맞는지.
2. 반환형이 올바른지.
3. 함수가 상단부에 선언이 됐는지.
4. 함수 범위에서 벗어난 변수를 사용하지 않는지.",
정의,B_LV1,C,함수 에러,,,{B_LV1}에 대해 알려줘,"함수를 사용하면서 오류가 발생할때 다음을 참고해보세요.

1. 매개변수의 개수와 자료형이 맞는지.
2. 반환형이 올바른지.
3. 함수가 상단부에 선언이 됐는지.
4. 함수 범위에서 벗어난 변수를 사용하지 않는지.",
정의,B_LV1,C,함수 배열,함수 배열,함수 배열 반환 인자 return,{B_LV1}에 대해 알려줘,"C언어에서 함수를 사용하면서 배열을 인자값으로 넘기거나 반환값으로 사용하기 위해서는 포인터 형식을 사용해야할 수 있습니다. 아래는 그 예시입니다.

int func1(int* arr){
  ~~~~
} 

int* func2( ){
  int arr[100];
  return arr
} 

이 방법이 어려울 경우,

int func3(int arr[]){
  ~~
}

이런식으로 크기를 비워두고 사용할 수도 있습니다.

참조https://zetawiki.com/wiki/C%EC%96%B8%EC%96%B4_%EB%B0%B0%EC%97%B4_%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0
",
정의,B_LV1,C,함수 배열 반환,,,{B_LV1}에 대해 알려줘,"C언어에서 함수를 사용하면서 배열을 인자값으로 넘기거나 반환값으로 사용하기 위해서는 포인터 형식을 사용해야할 수 있습니다. 아래는 그 예시입니다.

int func1(int* arr){
  ~~~~
} 

int* func2( ){
  int arr[100];
  return arr
} 

이 방법이 어려울 경우,

int func3(int arr[]){
  ~~
}

이런식으로 크기를 비워두고 사용할 수도 있습니다.

참조https://zetawiki.com/wiki/C%EC%96%B8%EC%96%B4_%EB%B0%B0%EC%97%B4_%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0
",
정의,B_LV1,C,함수 배열 인자,,,{B_LV1}에 대해 알려줘,"C언어에서 함수를 사용하면서 배열을 인자값으로 넘기거나 반환값으로 사용하기 위해서는 포인터 형식을 사용해야할 수 있습니다. 아래는 그 예시입니다.

int func1(int* arr){
  ~~~~
} 

int* func2( ){
  int arr[100];
  return arr
} 

이 방법이 어려울 경우,

int func3(int arr[]){
  ~~
}

이런식으로 크기를 비워두고 사용할 수도 있습니다.

참조https://zetawiki.com/wiki/C%EC%96%B8%EC%96%B4_%EB%B0%B0%EC%97%B4_%EB%B0%98%ED%99%98%ED%95%98%EA%B8%B0
",
정의,B_LV1,C,함수 반환 두개,함수 반환 여러개,함수 반환 리턴 두개 여러개 다중 return,{B_LV1}에 대해 알려줘,"C언어에서 리턴값을 두개 이상 반환하기 위해서는 배열을 이용하는 것이 가자 간편합니다. 함수 내에서 배열을 만들어서 함수의 반환형을 포인터형으로 바꾼 뒤, 배열을 리턴하게끔 해보세요! 이 방법이 이해가지않는다면, 함수와 배열이라고 질문해보세요!",
정의,B_LV1,C,함수 반환 여러개,,,{B_LV1}에 대해 알려줘,"C언어에서 리턴값을 두개 이상 반환하기 위해서는 배열을 이용하는 것이 가자 간편합니다. 함수 내에서 배열을 만들어서 함수의 반환형을 포인터형으로 바꾼 뒤, 배열을 리턴하게끔 해보세요! 이 방법이 이해가지않는다면, 함수와 배열이라고 질문해보세요!",
정의,B_LV1,C,함수 리턴 여러개,,,{B_LV1}에 대해 알려줘,"C언어에서 리턴값을 두개 이상 반환하기 위해서는 배열을 이용하는 것이 가자 간편합니다. 함수 내에서 배열을 만들어서 함수의 반환형을 포인터형으로 바꾼 뒤, 배열을 리턴하게끔 해보세요! 이 방법이 이해가지않는다면, 함수와 배열이라고 질문해보세요!",
정의,B_LV1,C,함수 리턴 두개,,,{B_LV1}에 대해 알려줘,"C언어에서 리턴값을 두개 이상 반환하기 위해서는 배열을 이용하는 것이 가자 간편합니다. 함수 내에서 배열을 만들어서 함수의 반환형을 포인터형으로 바꾼 뒤, 배열을 리턴하게끔 해보세요! 이 방법이 이해가지않는다면, 함수와 배열이라고 질문해보세요!",
정의,B_LV1,C,함수 파라미터,함수 파라미터,함수 파라미터 매개변수 인수,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어 집니다. 이때 매개변수란 함수에서 특정 값을 사용하기 위해서 초기에 받아오는 값들이라고 이해하면 좋습니다.
이러한 매개변수를 인수, 파라미터라고 부르기도합니다.
",
정의,B_LV1,C,함수 매개변수,,,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어 집니다. 이때 매개변수란 함수에서 특정 값을 사용하기 위해서 초기에 받아오는 값들이라고 이해하면 좋습니다.
이러한 매개변수를 인수, 파라미터라고 부르기도합니다.
",
정의,B_LV1,C,함수 인수,,,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어 집니다. 이때 매개변수란 함수에서 특정 값을 사용하기 위해서 초기에 받아오는 값들이라고 이해하면 좋습니다.
이러한 매개변수를 인수, 파라미터라고 부르기도합니다.
",
정의,B_LV1,C,함수 리턴,함수 반환,함수 리턴 return 반환 반환형,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어집니다. 함수들이 실행을 마친 후 특정 결과를 반환하고 싶을 때 우리는 return 키워드를 이용하여 값을 반환합니다. 이러한 반환 값들은 반환형과 자료형이 일치해야 합니다.
",
정의,B_LV1,C,함수 return,  ,,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어집니다. 함수들이 실행을 마친 후 특정 결과를 반환하고 싶을 때 우리는 return 키워드를 이용하여 값을 반환합니다. 이러한 반환 값들은 반환형과 자료형이 일치해야 합니다.
",
정의,B_LV1,C,함수 반환,,,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어집니다. 함수들이 실행을 마친 후 특정 결과를 반환하고 싶을 때 우리는 return 키워드를 이용하여 값을 반환합니다. 이러한 반환 값들은 반환형과 자료형이 일치해야 합니다.
",
정의,B_LV1,C,함수 반환형,,,{B_LV1}에 대해 알려줘,"C언어에서 함수는,
반환형 함수이름(매개변수1, 매개변수2, ... ){
         //몸체
         //return 반환값
}
위의 구조로 이루어집니다. 함수들이 실행을 마친 후 특정 결과를 반환하고 싶을 때 우리는 return 키워드를 이용하여 값을 반환합니다. 이러한 반환 값들은 반환형과 자료형이 일치해야 합니다.
",
정의,B_LV1,C,함수 종류,함수의 종류,함수 종류 사용자 정의 함수 표준 함수 라이브러리,{B_LV1}에 대해 알려줘,"C언어에서는 미리 정의해둔 함수인 (1)표준 라이브러리 함수와 프로그래머가 직접 만들어서 사용하는 (2)사용자 정의 함수가 있습니다.

표준 라이브러리 함수는 미리 정의가 돼있는 함수들로 우리가 많이 사용하는 printf, scanf들도 미리 정의된 표준 라이브러리 함수라고 할 수 있습니다. 이러한 표준 라이브러리 함수들은 특정 헤더 파일에 미리 정의돼 있는데, 우리가 코딩하기 전에 항상 맨 윗 줄에서 작성했었던 #include<stdio.h> 가 표준 입출력에 필요한 함수들을 정의해놓은 stdio 라는 해더 파일을 불러오는 역할을 한다고 생각하면 됩니다. 우리는 stdio.h 파일 이외에도 수학적 함수들을 모아놓은 math.h나 메모리 프로세스 제어를 도와주는 함수들을 도와주는 stdlib.h를 많이 사용합니다.

사용자 정의함수는 프로그래머가 직접 만들어서 사용하는 함수로, 주로 코드의 반복을 줄이고 효율을 높이기 위해서 사용합니다.

참조 : https://koonsland.tistory.com/34",
정의,B_LV1,C,사용자 정의 함수,,,{B_LV1}에 대해 알려줘,"C언어에서는 미리 정의해둔 함수인 (1)표준 라이브러리 함수와 프로그래머가 직접 만들어서 사용하는 (2)사용자 정의 함수가 있습니다.

표준 라이브러리 함수는 미리 정의가 돼있는 함수들로 우리가 많이 사용하는 printf, scanf들도 미리 정의된 표준 라이브러리 함수라고 할 수 있습니다. 이러한 표준 라이브러리 함수들은 특정 헤더 파일에 미리 정의돼 있는데, 우리가 코딩하기 전에 항상 맨 윗 줄에서 작성했었던 #include<stdio.h> 가 표준 입출력에 필요한 함수들을 정의해놓은 stdio 라는 해더 파일을 불러오는 역할을 한다고 생각하면 됩니다. 우리는 stdio.h 파일 이외에도 수학적 함수들을 모아놓은 math.h나 메모리 프로세스 제어를 도와주는 함수들을 도와주는 stdlib.h를 많이 사용합니다.

사용자 정의함수는 프로그래머가 직접 만들어서 사용하는 함수로, 주로 코드의 반복을 줄이고 효율을 높이기 위해서 사용합니다.

참조 : https://koonsland.tistory.com/34",
정의,B_LV1,C,표준 라이브러리 함수,,,{B_LV1}에 대해 알려줘,"C언어에서는 미리 정의해둔 함수인 (1)표준 라이브러리 함수와 프로그래머가 직접 만들어서 사용하는 (2)사용자 정의 함수가 있습니다.

표준 라이브러리 함수는 미리 정의가 돼있는 함수들로 우리가 많이 사용하는 printf, scanf들도 미리 정의된 표준 라이브러리 함수라고 할 수 있습니다. 이러한 표준 라이브러리 함수들은 특정 헤더 파일에 미리 정의돼 있는데, 우리가 코딩하기 전에 항상 맨 윗 줄에서 작성했었던 #include<stdio.h> 가 표준 입출력에 필요한 함수들을 정의해놓은 stdio 라는 해더 파일을 불러오는 역할을 한다고 생각하면 됩니다. 우리는 stdio.h 파일 이외에도 수학적 함수들을 모아놓은 math.h나 메모리 프로세스 제어를 도와주는 함수들을 도와주는 stdlib.h를 많이 사용합니다.

사용자 정의함수는 프로그래머가 직접 만들어서 사용하는 함수로, 주로 코드의 반복을 줄이고 효율을 높이기 위해서 사용합니다.

참조 : https://koonsland.tistory.com/34",
정의,B_LV1,C,함수 라이브러리,,,{B_LV1}에 대해 알려줘,"C언어에서는 미리 정의해둔 함수인 (1)표준 라이브러리 함수와 프로그래머가 직접 만들어서 사용하는 (2)사용자 정의 함수가 있습니다.

표준 라이브러리 함수는 미리 정의가 돼있는 함수들로 우리가 많이 사용하는 printf, scanf들도 미리 정의된 표준 라이브러리 함수라고 할 수 있습니다. 이러한 표준 라이브러리 함수들은 특정 헤더 파일에 미리 정의돼 있는데, 우리가 코딩하기 전에 항상 맨 윗 줄에서 작성했었던 #include<stdio.h> 가 표준 입출력에 필요한 함수들을 정의해놓은 stdio 라는 해더 파일을 불러오는 역할을 한다고 생각하면 됩니다. 우리는 stdio.h 파일 이외에도 수학적 함수들을 모아놓은 math.h나 메모리 프로세스 제어를 도와주는 함수들을 도와주는 stdlib.h를 많이 사용합니다.

사용자 정의함수는 프로그래머가 직접 만들어서 사용하는 함수로, 주로 코드의 반복을 줄이고 효율을 높이기 위해서 사용합니다.

참조 : https://koonsland.tistory.com/34",
정의,B_LV1,C,전역 변수 지역 변수,변수의 종류,전역 변수 지역 변수 변수 유효 범위 지역변수 전역변수,{B_LV1}에 대해 알려줘,"C언어에서는 변수가 선언되는 위치에 따라 해당 변수의 유효 범위, 메모리 반환 시기, 초기호 여부, 저장 장소등이 결정됩니다.

지역 변수는 한 함수 내에서 선언되는 변수들을 말합니다. 이러한 지역 변수들은 해당 함수가 종료되는 시점에서 사라지기 때문에 파라미터 또는 반환형으로 넘겨주지 않는다면 사용할 수 없습니다.

전역 변수란 함수 밖에서 선언되는 변수로, C코드의 어느곳에서나 사용할 수 있습니다. 이렇게 어느 곳에서나 사용할 수 있다는 것이 장점으로 다가오겠지만, 전역변수가 많다는 것은 할당이 해제되지 않은 데이터가 계속해서 메모리에 쌓이는 것이기 때문에 필요한 부분에 있어서 신중하게 사용하는 것이 좋습니다.

추천 참고 사이트
https://code4human.tistory.com/128",
정의,B_LV1,C,전역 변수,,,{B_LV1}에 대해 알려줘,"C언어에서는 변수가 선언되는 위치에 따라 해당 변수의 유효 범위, 메모리 반환 시기, 초기호 여부, 저장 장소등이 결정됩니다.

지역 변수는 한 함수 내에서 선언되는 변수들을 말합니다. 이러한 지역 변수들은 해당 함수가 종료되는 시점에서 사라지기 때문에 파라미터 또는 반환형으로 넘겨주지 않는다면 사용할 수 없습니다.

전역 변수란 함수 밖에서 선언되는 변수로, C코드의 어느곳에서나 사용할 수 있습니다. 이렇게 어느 곳에서나 사용할 수 있다는 것이 장점으로 다가오겠지만, 전역변수가 많다는 것은 할당이 해제되지 않은 데이터가 계속해서 메모리에 쌓이는 것이기 때문에 필요한 부분에 있어서 신중하게 사용하는 것이 좋습니다.

추천 참고 사이트
https://code4human.tistory.com/128",
정의,B_LV1,C,지역 변수,,,{B_LV1}에 대해 알려줘,"C언어에서는 변수가 선언되는 위치에 따라 해당 변수의 유효 범위, 메모리 반환 시기, 초기호 여부, 저장 장소등이 결정됩니다.

지역 변수는 한 함수 내에서 선언되는 변수들을 말합니다. 이러한 지역 변수들은 해당 함수가 종료되는 시점에서 사라지기 때문에 파라미터 또는 반환형으로 넘겨주지 않는다면 사용할 수 없습니다.

전역 변수란 함수 밖에서 선언되는 변수로, C코드의 어느곳에서나 사용할 수 있습니다. 이렇게 어느 곳에서나 사용할 수 있다는 것이 장점으로 다가오겠지만, 전역변수가 많다는 것은 할당이 해제되지 않은 데이터가 계속해서 메모리에 쌓이는 것이기 때문에 필요한 부분에 있어서 신중하게 사용하는 것이 좋습니다.

추천 참고 사이트
https://code4human.tistory.com/128",
정의,B_LV1,C,변수 유효 범위,,,{B_LV1}에 대해 알려줘,"C언어에서는 변수가 선언되는 위치에 따라 해당 변수의 유효 범위, 메모리 반환 시기, 초기호 여부, 저장 장소등이 결정됩니다.

지역 변수는 한 함수 내에서 선언되는 변수들을 말합니다. 이러한 지역 변수들은 해당 함수가 종료되는 시점에서 사라지기 때문에 파라미터 또는 반환형으로 넘겨주지 않는다면 사용할 수 없습니다.

전역 변수란 함수 밖에서 선언되는 변수로, C코드의 어느곳에서나 사용할 수 있습니다. 이렇게 어느 곳에서나 사용할 수 있다는 것이 장점으로 다가오겠지만, 전역변수가 많다는 것은 할당이 해제되지 않은 데이터가 계속해서 메모리에 쌓이는 것이기 때문에 필요한 부분에 있어서 신중하게 사용하는 것이 좋습니다.

추천 참고 사이트
https://code4human.tistory.com/128",
정의,B_LV1,C,전역변수 단점,전역변수 장단점,전역 변수 단점 장점 장단점,{B_LV1}에 대해 알려줘,"전역 변수란 함수 밖에서 선언되는 변수로, C코드의 어느곳에서나 사용할 수 있습니다. 이렇게 어느 곳에서나 사용할 수 있다는 것이 장점으로 다가오겠지만, 전역변수가 많다는 것은 할당이 해제되지 않은 데이터가 계속해서 메모리에 쌓이는 것이기 때문에 필요한 부분에 있어서 신중하게 사용하는 것이 좋습니다.",
정의,B_LV1,C,전역변수 장점,,,{B_LV1}에 대해 알려줘,"전역 변수란 함수 밖에서 선언되는 변수로, C코드의 어느곳에서나 사용할 수 있습니다. 이렇게 어느 곳에서나 사용할 수 있다는 것이 장점으로 다가오겠지만, 전역변수가 많다는 것은 할당이 해제되지 않은 데이터가 계속해서 메모리에 쌓이는 것이기 때문에 필요한 부분에 있어서 신중하게 사용하는 것이 좋습니다.",
정의,B_LV1,C,재귀,재귀 함수,재귀 함수 사용 사용법 재귀,{B_LV1}에 대해 알려줘,"재귀 함수란 함수 안에서 자기 자신을 호출하는 방식을 말합니다. 즉 함수 내부에서 자기 자신을 계속해서 호출하기 때문에 특정 조건없이는 멈추지 않고 무한히 반복되게 됩니다.

재귀 함수의 경우 초보자가 활용하기에는 부담스러운 부분이 분명 있는 활용 형태입니다. 하지만 재귀 호출이 어떻게 이루어지는 하나하나 과정을 그려보면서 이해해보면 어떠한 문제를 해결하기위한 아주 직관적인 해결법이 될 수 있습니다.

추천 참고 사이트 : https://thrillfighter.tistory.com/518",
정의,B_LV1,C,재귀 함수,,,{B_LV1}에 대해 알려줘,"재귀 함수란 함수 안에서 자기 자신을 호출하는 방식을 말합니다. 즉 함수 내부에서 자기 자신을 계속해서 호출하기 때문에 특정 조건없이는 멈추지 않고 무한히 반복되게 됩니다.

재귀 함수의 경우 초보자가 활용하기에는 부담스러운 부분이 분명 있는 활용 형태입니다. 하지만 재귀 호출이 어떻게 이루어지는 하나하나 과정을 그려보면서 이해해보면 어떠한 문제를 해결하기위한 아주 직관적인 해결법이 될 수 있습니다.

추천 참고 사이트 : https://thrillfighter.tistory.com/518",
정의,B_LV1,C,재귀 함수 사용,,,{B_LV1}에 대해 알려줘,"재귀 함수란 함수 안에서 자기 자신을 호출하는 방식을 말합니다. 재귀 함수는 로직이 복잡해지면 복잡해질수록 초보자 뿐만 아니라 숙련자들도  이해하기 힘든 활용 형태입니다. 뿐만 아니라 재귀적인 방식을 활용하지 않고 일반적인 반복문을 사용하는 것이 훨씬 효율적인 경우도 많습니다. 그럼에도 불구하고 재귀적인 방법을 사용하는 이유는 특정 문제를 해결하는데에서 직관적인 해답이 될 수 있기 때문입니다. 재귀 함수를 적절한 곳에  능숙하게 활용하시려면 많은 연습이 필요합니다.
",
정의,B_LV1,C,문자열,문자열,문자열 배열 사용 입력 출력,{B_LV1}에 대해 알려줘,"문자열은 큰따옴표("""")를 사용해서 표현되는 일련의 연속된 문자의 집합을 말합니다.
C언어에서 문자열을 선언하고 초기화하기 위해서는 char형 배열을 이용하거나 char형 포인터를 이용합니다.

char str1[100] = ""hello world"";
char *str2 = ""hello world"";

printf(""%s"",str1);
printf(""%s"",str2);

다음과 같이 활용할 수 있습니다.  이 때 문자 배열의 맨마지막에는 NULL 문자가 들어가게되는데 이를 '\0'이라고 표현합니다. 때문에 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.
",
정의,B_LV1,C,문자열 배열,,,{B_LV1}에 대해 알려줘,"문자열은 큰따옴표("""")를 사용해서 표현되는 일련의 연속된 문자의 집합을 말합니다.
C언어에서 문자열을 선언하고 초기화하기 위해서는 char형 배열을 이용하거나 char형 포인터를 이용합니다.

char str1[100] = ""hello world"";
char *str2 = ""hello world"";

printf(""%s"",str1);
printf(""%s"",str2);

다음과 같이 활용할 수 있습니다.  이 때 문자 배열의 맨마지막에는 NULL 문자가 들어가게되는데 이를 '\0'이라고 표현합니다. 때문에 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.
",
정의,B_LV1,C,문자열 사용,,,{B_LV1}에 대해 알려줘,"문자열은 큰따옴표("""")를 사용해서 표현되는 일련의 연속된 문자의 집합을 말합니다.
C언어에서 문자열을 선언하고 초기화하기 위해서는 char형 배열을 이용하거나 char형 포인터를 이용합니다.

char str1[100] = ""hello world"";
char *str2 = ""hello world"";

printf(""%s"",str1);
printf(""%s"",str2);

다음과 같이 활용할 수 있습니다.  이 때 문자 배열의 맨마지막에는 NULL 문자가 들어가게되는데 이를 '\0'이라고 표현합니다. 때문에 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.
",
정의,B_LV1,C,문자열 출력,,,{B_LV1}에 대해 알려줘,"문자열은 큰따옴표("""")를 사용해서 표현되는 일련의 연속된 문자의 집합을 말합니다.
C언어에서 문자열을 선언하고 초기화하기 위해서는 char형 배열을 이용하거나 char형 포인터를 이용합니다.

char str1[100] = ""hello world"";
char *str2 = ""hello world"";

printf(""%s"",str1);
printf(""%s"",str2);

다음과 같이 활용할 수 있습니다.  이 때 문자 배열의 맨마지막에는 NULL 문자가 들어가게되는데 이를 '\0'이라고 표현합니다. 때문에 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.
",
정의,B_LV1,C,문자열 입력,,,{B_LV1}에 대해 알려줘,"문자열은 큰따옴표("""")를 사용해서 표현되는 일련의 연속된 문자의 집합을 말합니다.
C언어에서 문자열을 선언하고 초기화하기 위해서는 char형 배열을 이용하거나 char형 포인터를 이용합니다.

char str1[100] = ""hello world"";
char *str2 = ""hello world"";

printf(""%s"",str1);
printf(""%s"",str2);

다음과 같이 활용할 수 있습니다.  이 때 문자 배열의 맨마지막에는 NULL 문자가 들어가게되는데 이를 '\0'이라고 표현합니다. 때문에 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.
",
정의,B_LV1,C,문자열 입력 출력,,,{B_LV1}에 대해 알려줘,"문자열은 큰따옴표("""")를 사용해서 표현되는 일련의 연속된 문자의 집합을 말합니다.
C언어에서 문자열을 선언하고 초기화하기 위해서는 char형 배열을 이용하거나 char형 포인터를 이용합니다.

char str1[100] = ""hello world"";
char *str2 = ""hello world"";

printf(""%s"",str1);
printf(""%s"",str2);

다음과 같이 활용할 수 있습니다.  이 때 문자 배열의 맨마지막에는 NULL 문자가 들어가게되는데 이를 '\0'이라고 표현합니다. 때문에 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.
",
정의,B_LV1,C,널 문자,널 문자,널 문자 null NULL Null,{B_LV1}에 대해 알려줘,"NULL 문자는 문자 배열의 끝을 알려주는 값입니다.
이러한 NULL 문자를 '\0'으로 표현하고 아스키코드 값은 0입니다.
C언어에서 문자열을 표현할 때 NULL 문자가 맨마지막에 삽입되기때문에 실제 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.",
정의,B_LV1,C,null NULL,,,{B_LV1}에 대해 알려줘,"NULL 문자는 문자 배열의 끝을 알려주는 값입니다.
이러한 NULL 문자를 '\0'으로 표현하고 아스키코드 값은 0입니다.
C언어에서 문자열을 표현할 때 NULL 문자가 맨마지막에 삽입되기때문에 실제 문자열의 크기는 실제 문자의 개수 + NULL 문자 입니다.",
정의,B_LV1,C,문자열 함수,문자열 함수,문자열 함수 비교 합치기 연결 길이,{B_LV1}에 대해 알려줘,"C언어에서는 문자열을 처리하기 위한 표준 함수들을 제공하고 있습니다.
그 함수들을 사용하기위해서 #include <string.h>을 적어줘야 합니다.

1. strcmp,strncmp : 문자열비교

2. strcat, strncat : 문자열 연결

3. strcpy, strncpy : 문자열 복사

4. strlen : 문자열 길이 반환

5. atoi, atof, atol : 인수로 전달된 숫자 타입을 문자열로 변환.

6. toupper, tolower : 인수로 전달된 영문자 문자열을 전부 대문자, 소문자로 변환.

각각 함수의 상세한 정보를 알고싶으면 함수명으로 질문해보세요!

참조
http://tcpschool.com/c/c_string_handling
",
정의,B_LV1,C,문자열 비교,,,{B_LV1}에 대해 알려줘,"C언어에서는 문자열을 처리하기 위한 표준 함수들을 제공하고 있습니다.
그 함수들을 사용하기위해서 #include <string.h>을 적어줘야 합니다.

1. strcmp,strncmp : 문자열비교

2. strcat, strncat : 문자열 연결

3. strcpy, strncpy : 문자열 복사

4. strlen : 문자열 길이 반환

5. atoi, atof, atol : 인수로 전달된 숫자 타입을 문자열로 변환.

6. toupper, tolower : 인수로 전달된 영문자 문자열을 전부 대문자, 소문자로 변환.

각각 함수의 상세한 정보를 알고싶으면 함수명으로 질문해보세요!

참조
http://tcpschool.com/c/c_string_handling
",
정의,B_LV1,C,문자열 합치기,,,{B_LV1}에 대해 알려줘,"C언어에서는 문자열을 처리하기 위한 표준 함수들을 제공하고 있습니다.
그 함수들을 사용하기위해서 #include <string.h>을 적어줘야 합니다.

1. strcmp,strncmp : 문자열비교

2. strcat, strncat : 문자열 연결

3. strcpy, strncpy : 문자열 복사

4. strlen : 문자열 길이 반환

5. atoi, atof, atol : 인수로 전달된 숫자 타입을 문자열로 변환.

6. toupper, tolower : 인수로 전달된 영문자 문자열을 전부 대문자, 소문자로 변환.

각각 함수의 상세한 정보를 알고싶으면 함수명으로 질문해보세요!

참조
http://tcpschool.com/c/c_string_handling
",
정의,B_LV1,C,문자열 연결,,,{B_LV1}에 대해 알려줘,"C언어에서는 문자열을 처리하기 위한 표준 함수들을 제공하고 있습니다.
그 함수들을 사용하기위해서 #include <string.h>을 적어줘야 합니다.

1. strcmp,strncmp : 문자열비교

2. strcat, strncat : 문자열 연결

3. strcpy, strncpy : 문자열 복사

4. strlen : 문자열 길이 반환

5. atoi, atof, atol : 인수로 전달된 숫자 타입을 문자열로 변환.

6. toupper, tolower : 인수로 전달된 영문자 문자열을 전부 대문자, 소문자로 변환.

각각 함수의 상세한 정보를 알고싶으면 함수명으로 질문해보세요!

참조
http://tcpschool.com/c/c_string_handling
",
정의,B_LV1,C,문자열 길이,,,{B_LV1}에 대해 알려줘,"C언어에서는 문자열을 처리하기 위한 표준 함수들을 제공하고 있습니다.
그 함수들을 사용하기위해서 #include <string.h>을 적어줘야 합니다.

1. strcmp,strncmp : 문자열비교

2. strcat, strncat : 문자열 연결

3. strcpy, strncpy : 문자열 복사

4. strlen : 문자열 길이 반환

5. atoi, atof, atol : 인수로 전달된 숫자 타입을 문자열로 변환.

6. toupper, tolower : 인수로 전달된 영문자 문자열을 전부 대문자, 소문자로 변환.

각각 함수의 상세한 정보를 알고싶으면 함수명으로 질문해보세요!

참조
http://tcpschool.com/c/c_string_handling
",
정의,B_LV1,C,문자열 비교 함수,문자열 비교 함수,문자열 비교 함수 방법 strcmp strncmp,{B_LV1}에 대해 알려줘,"strcmp,strncmp : 문자열비교

strcmp(str1,str2)
문자열은 == 연산자를 사용해서 비교하지 못합니다. == 연산자를 사용하면 문자열 자체의 주소값을 비교하기 때문입니다. 문자열이 같은 내용의 문자열인지를 확인하기 위해서는 strcmp 함수를 이용합니다. 비교 대상이 같을 경우 1을 아닐 경우 0을 반환합니다.

strncmp(str1, str2, n) 함수 같은 경우 세번째 인자로 전달된 n만큼을 비교합니다.",
정의,B_LV1,C,문자열 비교 방법,,,{B_LV1}에 대해 알려줘,"strcmp,strncmp : 문자열비교

strcmp(str1,str2)
문자열은 == 연산자를 사용해서 비교하지 못합니다. == 연산자를 사용하면 문자열 자체의 주소값을 비교하기 때문입니다. 문자열이 같은 내용의 문자열인지를 확인하기 위해서는 strcmp 함수를 이용합니다. 비교 대상이 같을 경우 1을 아닐 경우 0을 반환합니다.

strncmp(str1, str2, n) 함수 같은 경우 세번째 인자로 전달된 n만큼을 비교합니다.",
정의,B_LV1,C,strcmp,,,{B_LV1}에 대해 알려줘,"strcmp,strncmp : 문자열비교

strcmp(str1,str2)
문자열은 == 연산자를 사용해서 비교하지 못합니다. == 연산자를 사용하면 문자열 자체의 주소값을 비교하기 때문입니다. 문자열이 같은 내용의 문자열인지를 확인하기 위해서는 strcmp 함수를 이용합니다. 비교 대상이 같을 경우 1을 아닐 경우 0을 반환합니다.

strncmp(str1, str2, n) 함수 같은 경우 세번째 인자로 전달된 n만큼을 비교합니다.",
정의,B_LV1,C,strncmp,,,{B_LV1}에 대해 알려줘,"strcmp,strncmp : 문자열비교

strcmp(str1,str2)
문자열은 == 연산자를 사용해서 비교하지 못합니다. == 연산자를 사용하면 문자열 자체의 주소값을 비교하기 때문입니다. 문자열이 같은 내용의 문자열인지를 확인하기 위해서는 strcmp 함수를 이용합니다. 비교 대상이 같을 경우 1을 아닐 경우 0을 반환합니다.

strncmp(str1, str2, n) 함수 같은 경우 세번째 인자로 전달된 n만큼을 비교합니다.",
정의,B_LV1,C,문자열 연결 함수,문자열 연결 함수,문자열 합치기 연결 함수 방법 strcat strncat,{B_LV1}에 대해 알려줘,"strcat, strncat : 문자열 연결

strcat 함수는 하나의 문자열과 다른 문자열을 연결해주는 함수입니다.
strcat(str1,str2)
이 때, 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문자열이 뒤로 추가됩니다.

strncat(str1,str2,n)
strncat 함수는 세 번째 인수로 최대 크기 n을 지정해줄 수 있습니다. strcat함수 같은 경우 첫 번째 인수의 최대 크기를 넘길 경우 오버플로우 문제가 발생할 수 있지만 strncat을 이용하면 이를 방지할 수 있습니다.",
정의,B_LV1,C,문자열 합치기,,,{B_LV1}에 대해 알려줘,"strcat, strncat : 문자열 연결

strcat 함수는 하나의 문자열과 다른 문자열을 연결해주는 함수입니다.
strcat(str1,str2)
이 때, 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문자열이 뒤로 추가됩니다.

strncat(str1,str2,n)
strncat 함수는 세 번째 인수로 최대 크기 n을 지정해줄 수 있습니다. strcat함수 같은 경우 첫 번째 인수의 최대 크기를 넘길 경우 오버플로우 문제가 발생할 수 있지만 strncat을 이용하면 이를 방지할 수 있습니다.",
정의,B_LV1,C,문자열 연결 방법,,,{B_LV1}에 대해 알려줘,"strcat, strncat : 문자열 연결

strcat 함수는 하나의 문자열과 다른 문자열을 연결해주는 함수입니다.
strcat(str1,str2)
이 때, 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문자열이 뒤로 추가됩니다.

strncat(str1,str2,n)
strncat 함수는 세 번째 인수로 최대 크기 n을 지정해줄 수 있습니다. strcat함수 같은 경우 첫 번째 인수의 최대 크기를 넘길 경우 오버플로우 문제가 발생할 수 있지만 strncat을 이용하면 이를 방지할 수 있습니다.",
정의,B_LV1,C,문자열 합치기 방법,,,{B_LV1}에 대해 알려줘,"strcat, strncat : 문자열 연결

strcat 함수는 하나의 문자열과 다른 문자열을 연결해주는 함수입니다.
strcat(str1,str2)
이 때, 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문자열이 뒤로 추가됩니다.

strncat(str1,str2,n)
strncat 함수는 세 번째 인수로 최대 크기 n을 지정해줄 수 있습니다. strcat함수 같은 경우 첫 번째 인수의 최대 크기를 넘길 경우 오버플로우 문제가 발생할 수 있지만 strncat을 이용하면 이를 방지할 수 있습니다.",
정의,B_LV1,C,strcat,,,{B_LV1}에 대해 알려줘,"strcat, strncat : 문자열 연결

strcat 함수는 하나의 문자열과 다른 문자열을 연결해주는 함수입니다.
strcat(str1,str2)
이 때, 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문자열이 뒤로 추가됩니다.

strncat(str1,str2,n)
strncat 함수는 세 번째 인수로 최대 크기 n을 지정해줄 수 있습니다. strcat함수 같은 경우 첫 번째 인수의 최대 크기를 넘길 경우 오버플로우 문제가 발생할 수 있지만 strncat을 이용하면 이를 방지할 수 있습니다.",
정의,B_LV1,C,strncat,,,{B_LV1}에 대해 알려줘,"strcat, strncat : 문자열 연결

strcat 함수는 하나의 문자열과 다른 문자열을 연결해주는 함수입니다.
strcat(str1,str2)
이 때, 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문자열이 뒤로 추가됩니다.

strncat(str1,str2,n)
strncat 함수는 세 번째 인수로 최대 크기 n을 지정해줄 수 있습니다. strcat함수 같은 경우 첫 번째 인수의 최대 크기를 넘길 경우 오버플로우 문제가 발생할 수 있지만 strncat을 이용하면 이를 방지할 수 있습니다.",
정의,B_LV1,C,문자열 복사 함수,문자열 복사 함수,문자열 복사 함수 방법 strcpy strncpy,{B_LV1}에 대해 알려줘,"strcpy, strncpy : 문자열 복사

strcpy(str1,str2)
strcpy 함수는 문자열을 복사하는 함수입니다. 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문장열을 복사합니다.

strncpy(str1, str2, n)
strncpy 함수는 strcpy 함수와 기능은 같지만 세 번째로 인수로 복사할 문자열의 최대길이를 지정할 수 있습니다. 즉 str2에서 n만큼만 str1로 복사합니다.",
정의,B_LV1,C,문자열 복사 방법,,,{B_LV1}에 대해 알려줘,"strcpy, strncpy : 문자열 복사

strcpy(str1,str2)
strcpy 함수는 문자열을 복사하는 함수입니다. 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문장열을 복사합니다.

strncpy(str1, str2, n)
strncpy 함수는 strcpy 함수와 기능은 같지만 세 번째로 인수로 복사할 문자열의 최대길이를 지정할 수 있습니다. 즉 str2에서 n만큼만 str1로 복사합니다.",
정의,B_LV1,C,strcpy,,,{B_LV1}에 대해 알려줘,"strcpy, strncpy : 문자열 복사

strcpy(str1,str2)
strcpy 함수는 문자열을 복사하는 함수입니다. 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문장열을 복사합니다.

strncpy(str1, str2, n)
strncpy 함수는 strcpy 함수와 기능은 같지만 세 번째로 인수로 복사할 문자열의 최대길이를 지정할 수 있습니다. 즉 str2에서 n만큼만 str1로 복사합니다.",
정의,B_LV1,C,strncpy,,,{B_LV1}에 대해 알려줘,"strcpy, strncpy : 문자열 복사

strcpy(str1,str2)
strcpy 함수는 문자열을 복사하는 함수입니다. 첫 번째 인수로 전달된 문자열에 두 번째 인수로 전달된 문장열을 복사합니다.

strncpy(str1, str2, n)
strncpy 함수는 strcpy 함수와 기능은 같지만 세 번째로 인수로 복사할 문자열의 최대길이를 지정할 수 있습니다. 즉 str2에서 n만큼만 str1로 복사합니다.",
정의,B_LV1,C,문자열 길이 함수,문자열 길이 함수,문자열 길이 함수 strlen,{B_LV1}에 대해 알려줘,"strlen : 문자열 길이

strlen(str1)
인수로 전달된 문자열의 길이를 반환합니다. 이 때, 문자열의 맨 마지막인 null 문자는 문자열의 길이에서 제외됩니다.",
정의,B_LV1,C,strlen,,,{B_LV1}에 대해 알려줘,"strlen : 문자열 길이

strlen(str1)
인수로 전달된 문자열의 길이를 반환합니다. 이 때, 문자열의 맨 마지막인 null 문자는 문자열의 길이에서 제외됩니다.",
정의,B_LV1,C,문자열 정수,문자열 정수 변환,문자열 정수 숫자 변환 int float double atoi atol atof,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 int,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 double,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 float,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 숫자 변환,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 숫자,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 변환,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,atoi,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,atof,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,atol,,,{B_LV1}에 대해 알려줘,"atoi, atof, atol : 문자열 숫자로 변환

#include <stdlib.h> <- 선언 필요!
atoi(str);          // int형 정수로 변환.
atol(str);          // long형 정수로 변환.
atof(str);         // double형 실수로 변환. ",
정의,B_LV1,C,문자열 소문자,문자열 대소문자 변환,문자열 대문자 소문자 대소문자 변환 tolower toupper,{B_LV1}에 대해 알려줘,"toupper, tolower : 인수 전달된 문자를 소문자 or 대문자로 변환.

#include <ctype.h> <- 선언 필요
toupper(char);     // 영문자를 대문자로 변환함.
tolower(char);     // 영문자를 소문자로 변환함. ",
정의,B_LV1,C,문자열 대문자,,,{B_LV1}에 대해 알려줘,"toupper, tolower : 인수 전달된 문자를 소문자 or 대문자로 변환.

#include <ctype.h> <- 선언 필요
toupper(char);     // 영문자를 대문자로 변환함.
tolower(char);     // 영문자를 소문자로 변환함. ",
정의,B_LV1,C,문자열 바꾸기,,,{B_LV1}에 대해 알려줘,"toupper, tolower : 인수 전달된 문자를 소문자 or 대문자로 변환.

#include <ctype.h> <- 선언 필요
toupper(char);     // 영문자를 대문자로 변환함.
tolower(char);     // 영문자를 소문자로 변환함. ",
정의,B_LV1,C,toupper,,,{B_LV1}에 대해 알려줘,"toupper, tolower : 인수 전달된 문자를 소문자 or 대문자로 변환.

#include <ctype.h> <- 선언 필요
toupper(char);     // 영문자를 대문자로 변환함.
tolower(char);     // 영문자를 소문자로 변환함. ",
정의,B_LV1,C,tolower,,,{B_LV1}에 대해 알려줘,"toupper, tolower : 인수 전달된 문자를 소문자 or 대문자로 변환.

#include <ctype.h> <- 선언 필요
toupper(char);     // 영문자를 대문자로 변환함.
tolower(char);     // 영문자를 소문자로 변환함. ",
정의,B_LV1,C,포인터,포인터,포인터 정의 변수 초기화 개념 이유 사용,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,포인터 변수,,,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,포인터 초기화,,,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,포인터 정의,,,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,포인터 개념,,,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,포인터 이유,,,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,포인터 사용,,,{B_LV1}에 대해 알려줘,"포인터는 C언어의 꽃이자 초심자 분들이 정말로 싫어하는 주제입니다.
포인터란 메모리의 주소값을 저장하는 변수를 의미합니다. char 변수가 문자값을 저장하고 int 형 변수가 정수값을 저장하는 것처럼 포인터 변수는 주소값을 저장합니다. 이름에도 알 수 있듯이 주소를 포인트하는 값이라고 이해하시면 될 것 같습니다.

int n = 5;
int *p = &n;

위의 코드 처럼 포인터 * 연산자를 통해서 포인터 변수를 선언할 수 있습니다. 또한 어떠한 변수 앞에 & 연산자를 붙이면 그 변수의 주소값을 가르키게 됩니다. 즉, 위 코드에서 우리는 n이라는 정수형 변수를 5로 초기화하고 p라는 포인터 형 변수가 n이라는 변수의 주소값을 가르키게 한 것 입니다. 이때 * 연산자를 주소 연산자라고 하고, * 연산자를 참조 연산자라고 합니다.

위에서도 설명했듯 C언어에서 포인터는 정말 아름다운 개념입니다. 프로그래머가 주소값까지 직접 접근할 수 있다는 것은 치명적인 단점이 될 수도 있지만, 프로그램의 깊숙한 메모리까지 설정할 수 있다는 뜻이기도 합니다.

참조
http://tcpschool.com/c/c_pointer_intro
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271954/%ED%8F%AC%EC%9D%B8%ED%84%B0%EB%9E%80",
정의,B_LV1,C,&,주소 연산자,& 주소연산자,{B_LV1}에 대해 알려줘,"C언어에서 &은 주소 연산자입니다. 특정 변수 앞에 &연산자를 붙이게 되면, 해당 변수의 주소값을 가르키게 됩니다. 우리가 흔히 쓰는 scanf 함수를 살펴보겠습니다.

int n;
scanf(""%d"",&n);

우리는 관습적으로 주소 연산자를 scanf를 사용해왔습니다. scanf 함수에서는 두번째 인자로 변수의 주소값을 넘겨주면 그 변수의 주소로 가서 입력값을 변수로 초기화해주는 기능을 하는 것입니다.",
정의,B_LV1,C,주소 연산자,,,{B_LV1}에 대해 알려줘,"C언어에서 &은 주소 연산자입니다. 특정 변수 앞에 &연산자를 붙이게 되면, 해당 변수의 주소값을 가르키게 됩니다. 우리가 흔히 쓰는 scanf 함수를 살펴보겠습니다.

int n;
scanf(""%d"",&n);

우리는 관습적으로 주소 연산자를 scanf를 사용해왔습니다. scanf 함수에서는 두번째 인자로 변수의 주소값을 넘겨주면 그 변수의 주소로 가서 입력값을 변수로 초기화해주는 기능을 하는 것입니다.",
정의,B_LV1,C,*,참조 연산자,* 참조 연산자,{B_LV1}에 대해 알려줘,"포인터에서 *은 참조 연산자입니다.

int *p = &n;

다음과 같이 변수 앞에 참조 연산자를 붙이면 포인터 변수로 선언을 할 수 있습니다.

int n = 5;
int *p = &n;
printf(""%d"",p);        // 1
printf(""%d"",*p);       // 2

1번에서 p를 프린트하게 되면 p는 포인터이기때문에 n의 주소를 가르키됩니다.
2번에서 *p를 프린트하게 되면 p가 가르키는 주소의 변수 값을 반환합니다. 즉, 5를 출력할 것 입니다.

참조
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271951/%EC%B0%B8%EC%A1%B0-%EC%97%B0%EC%82%B0%EC%9E%90
",
정의,B_LV1,C,참조 연산자,,,{B_LV1}에 대해 알려줘,"포인터에서 *은 참조 연산자입니다.

int *p = &n;

다음과 같이 변수 앞에 참조 연산자를 붙이면 포인터 변수로 선언을 할 수 있습니다.

int n = 5;
int *p = &n;
printf(""%d"",p);        // 1
printf(""%d"",*p);       // 2

1번에서 p를 프린트하게 되면 p는 포인터이기때문에 n의 주소를 가르키됩니다.
2번에서 *p를 프린트하게 되면 p가 가르키는 주소의 변수 값을 반환합니다. 즉, 5를 출력할 것 입니다.

참조
https://khu.goorm.io/learn/lecture/201/%ED%95%9C-%EB%88%88%EC%97%90-%EB%81%9D%EB%82%B4%EB%8A%94-c%EC%96%B8%EC%96%B4-%EA%B8%B0%EC%B4%88/lesson/1271951/%EC%B0%B8%EC%A1%B0-%EC%97%B0%EC%82%B0%EC%9E%90
",
정의,B_LV1,C,null 포인터,NULL 포인터,NULL null 포인터,{B_LV1}에 대해 알려줘,"포인터는 선언함과 동시에 초기화하는 것이 일반적입니다. 하지만 그것이 불가능한 상황에서 보통 NULL 포인터로 초기화하는 것이 권장됩니다.

Int *p = NULL;

이 때의 NULL을 NULL 포인터라고 하며 초기화된 p 포인터는 아무것도 없는 주소를 가르키게 됩니다. 이렇게 NULL 포인터를 가르키게 하는 것이 권장되는 이유는 포인터를 초기화하지 않고 이용하면서 잘못된 주소를 가르키되면 여러가지 오류가 발생할 수 있기 때문입니다.",
정의,B_LV1,C,NULL 포인터,,,{B_LV1}에 대해 알려줘,"포인터는 선언함과 동시에 초기화하는 것이 일반적입니다. 하지만 그것이 불가능한 상황에서 보통 NULL 포인터로 초기화하는 것이 권장됩니다.

Int *p = NULL;

이 때의 NULL을 NULL 포인터라고 하며 초기화된 p 포인터는 아무것도 없는 주소를 가르키게 됩니다. 이렇게 NULL 포인터를 가르키게 하는 것이 권장되는 이유는 포인터를 초기화하지 않고 이용하면서 잘못된 주소를 가르키되면 여러가지 오류가 발생할 수 있기 때문입니다.",
정의,B_LV1,C,포인터 장점,포인터 장단점,포인터 장점 단점 장단점 이유 사용 이유 필요 이유,{B_LV1}에 대해 알려줘,"C언어 초심자분들 어렵기만한 포인터를 왜쓰는지 의아하실겁니다.
포인터는 프로그래머가 주소에 직접적으로 접근할 수 있게끔 만들어줍니다. 프로그래머들은 이러한 주소값을 통해서 변수를 직접적으로 제어할 수 있고 마음대로 응용할 수 있습니다.

포인터의 장점
복잡한 자료구조를 효율적으로 처리할 수 있고 메모리 공간을 효율적으로 사용할 수 있게 됩니다. 
또한 배열이나 문자열을 편리하게 다룰 수 있으며 힙 영역(동적 할당 메모리 영역)에 접근 및 조작이 용이해집니다.

포인터 단점
주소에 직접적으로 접근한다는 것은 프로그램에게 매우 치명적인 행동이 될 수 있습니다. 그렇기 때문에 포인터를 적절하게 활용하기 위해서 연습이 요구됩니다.

참조 : https://oper6210.tistory.com/160",
정의,B_LV1,C,포인터 단점,,,{B_LV1}에 대해 알려줘,"C언어 초심자분들 어렵기만한 포인터를 왜쓰는지 의아하실겁니다.
포인터는 프로그래머가 주소에 직접적으로 접근할 수 있게끔 만들어줍니다. 프로그래머들은 이러한 주소값을 통해서 변수를 직접적으로 제어할 수 있고 마음대로 응용할 수 있습니다.

포인터의 장점
복잡한 자료구조를 효율적으로 처리할 수 있고 메모리 공간을 효율적으로 사용할 수 있게 됩니다. 
또한 배열이나 문자열을 편리하게 다룰 수 있으며 힙 영역(동적 할당 메모리 영역)에 접근 및 조작이 용이해집니다.

포인터 단점
주소에 직접적으로 접근한다는 것은 프로그램에게 매우 치명적인 행동이 될 수 있습니다. 그렇기 때문에 포인터를 적절하게 활용하기 위해서 연습이 요구됩니다.

참조 : https://oper6210.tistory.com/160",
정의,B_LV1,C,포인터 이유,,,{B_LV1}에 대해 알려줘,"C언어 초심자분들 어렵기만한 포인터를 왜쓰는지 의아하실겁니다.
포인터는 프로그래머가 주소에 직접적으로 접근할 수 있게끔 만들어줍니다. 프로그래머들은 이러한 주소값을 통해서 변수를 직접적으로 제어할 수 있고 마음대로 응용할 수 있습니다.

포인터의 장점
복잡한 자료구조를 효율적으로 처리할 수 있고 메모리 공간을 효율적으로 사용할 수 있게 됩니다. 
또한 배열이나 문자열을 편리하게 다룰 수 있으며 힙 영역(동적 할당 메모리 영역)에 접근 및 조작이 용이해집니다.

포인터 단점
주소에 직접적으로 접근한다는 것은 프로그램에게 매우 치명적인 행동이 될 수 있습니다. 그렇기 때문에 포인터를 적절하게 활용하기 위해서 연습이 요구됩니다.

참조 : https://oper6210.tistory.com/160",
정의,B_LV1,C,포인터 사용 이유,,,{B_LV1}에 대해 알려줘,"C언어 초심자분들 어렵기만한 포인터를 왜쓰는지 의아하실겁니다.
포인터는 프로그래머가 주소에 직접적으로 접근할 수 있게끔 만들어줍니다. 프로그래머들은 이러한 주소값을 통해서 변수를 직접적으로 제어할 수 있고 마음대로 응용할 수 있습니다.

포인터의 장점
복잡한 자료구조를 효율적으로 처리할 수 있고 메모리 공간을 효율적으로 사용할 수 있게 됩니다. 
또한 배열이나 문자열을 편리하게 다룰 수 있으며 힙 영역(동적 할당 메모리 영역)에 접근 및 조작이 용이해집니다.

포인터 단점
주소에 직접적으로 접근한다는 것은 프로그램에게 매우 치명적인 행동이 될 수 있습니다. 그렇기 때문에 포인터를 적절하게 활용하기 위해서 연습이 요구됩니다.

참조 : https://oper6210.tistory.com/160",
정의,B_LV1,C,포인터 필요 이유,,,{B_LV1}에 대해 알려줘,"C언어 초심자분들 어렵기만한 포인터를 왜쓰는지 의아하실겁니다.
포인터는 프로그래머가 주소에 직접적으로 접근할 수 있게끔 만들어줍니다. 프로그래머들은 이러한 주소값을 통해서 변수를 직접적으로 제어할 수 있고 마음대로 응용할 수 있습니다.

포인터의 장점
복잡한 자료구조를 효율적으로 처리할 수 있고 메모리 공간을 효율적으로 사용할 수 있게 됩니다. 
또한 배열이나 문자열을 편리하게 다룰 수 있으며 힙 영역(동적 할당 메모리 영역)에 접근 및 조작이 용이해집니다.

포인터 단점
주소에 직접적으로 접근한다는 것은 프로그램에게 매우 치명적인 행동이 될 수 있습니다. 그렇기 때문에 포인터를 적절하게 활용하기 위해서 연습이 요구됩니다.

참조 : https://oper6210.tistory.com/160",
